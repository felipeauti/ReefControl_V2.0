#include "SensorManager.h"

void SensorManager::readAll() {
    readTemperature();
    readPH();
    readTDS();
    readWaterLevel();
    checkAlerts();
    validateReadings();
    _data.totalReadings++;
    _data.lastReadTime = millis();
}

void SensorManager::update() {
    if (millis() - _data.lastReadTime >= _data.readInterval) {
        readAll();
    }
}

void SensorManager::readTemperature() {
    if (millis() - _data.tempLastRead < _data.readInterval) return;
    
    Serial.println("\nüå°Ô∏è Lendo temperaturas...");
    
    // Primeiro l√™ todos os sensores f√≠sicos
    DeviceAddress addr;
    int deviceCount = _tempSensor.getDeviceCount();
    Serial.printf("üìä Total de sensores f√≠sicos: %d\n", deviceCount);
    
    _tempSensor.requestTemperatures();
    bool anyValidReading = false;
    
    // L√™ todos os sensores f√≠sicos encontrados
    for(int i=0; i<deviceCount; i++) {
        if(_tempSensor.getAddress(addr, i)) {
            // Mostra endere√ßo
            Serial.print("üîç Endere√ßo do sensor ");
            Serial.print(i);
            Serial.print(": ");
            for (uint8_t j = 0; j < 8; j++) {
                if (addr[j] < 16) Serial.print("0");
                Serial.print(addr[j], HEX);
            }
            Serial.println();
            
            // Mostra resolu√ß√£o
            Serial.printf("üìä Resolu√ß√£o: %d bits\n", _tempSensor.getResolution(addr));
            
            // L√™ temperatura
            float rawTemp = _tempSensor.getTempC(addr);
            if (rawTemp != DEVICE_DISCONNECTED_C && rawTemp > -50 && rawTemp < 100) {
                Serial.printf("üì° Temperatura: %.2f¬∞C\n", rawTemp);
                anyValidReading = true;
            } else {
                Serial.printf("‚ùå Erro ao ler temperatura! (%.2f¬∞C)\n", rawTemp);
            }
        }
    }

    // Agora l√™ os sensores cadastrados
    Serial.printf("\nüìä Sensores cadastrados: %d\n", _numDS18B20Sensors);
    
    for(int i=0; i<_numDS18B20Sensors; i++) {
        Serial.printf("üîç Lendo sensor %d ('%s')...\n", i, _ds18b20Sensors[i].name.c_str());
        
        // Debug do endere√ßo
        Serial.print("üìç Endere√ßo: ");
        for (uint8_t j = 0; j < 8; j++) {
            if (_ds18b20Sensors[i].address[j] < 16) Serial.print("0");
            Serial.print(_ds18b20Sensors[i].address[j], HEX);
        }
        Serial.println();
        
        float rawTemp = _tempSensor.getTempC(_ds18b20Sensors[i].address);
        Serial.printf("üì° Temperatura raw: %.2f¬∞C\n", rawTemp);
        
        if (rawTemp != DEVICE_DISCONNECTED_C && rawTemp > -50 && rawTemp < 100) {
            _ds18b20Sensors[i].rawTemperature = rawTemp;
            _ds18b20Sensors[i].temperature = rawTemp + _ds18b20Sensors[i].offset;
            _ds18b20Sensors[i].isValid = true;
            _ds18b20Sensors[i].lastRead = millis();
            anyValidReading = true;

            Serial.printf("‚úÖ %s: %.2f¬∞C (raw: %.2f¬∞C, offset: %.2f¬∞C)\n", 
                _ds18b20Sensors[i].name.c_str(),
                _ds18b20Sensors[i].temperature,
                _ds18b20Sensors[i].rawTemperature,
                _ds18b20Sensors[i].offset);
        } else {
            _ds18b20Sensors[i].isValid = false;
            Serial.printf("‚ùå Erro ao ler sensor '%s'! (%.2f¬∞C)\n", 
                _ds18b20Sensors[i].name.c_str(), 
                rawTemp);
        }
    }

    _data.tempValid = anyValidReading;
    _data.tempLastRead = millis();
    
    if (!anyValidReading) {
        Serial.println("\n‚ö†Ô∏è Nenhuma leitura v√°lida obtida!");
    }
    Serial.println();
}

void SensorManager::readPH() {
    // Implementa√ß√£o futura
    _data.phValid = false;
}

void SensorManager::readTDS() {
    // Implementa√ß√£o futura
    _data.tdsValid = false;
}

void SensorManager::readWaterLevel() {
    // Implementa√ß√£o futura
    _data.levelValid = false;
}

float SensorManager::calculateMovingAverage(float* array, float newValue) {
    array[_historyIndex] = newValue;
    _historyIndex = (_historyIndex + 1) % MOVING_AVERAGE_SIZE;
    if (_historyIndex == 0) _historyFull = true;
    
    float sum = 0;
    int count = _historyFull ? MOVING_AVERAGE_SIZE : _historyIndex;
    for (int i = 0; i < count; i++) {
        sum += array[i];
    }
    return sum / count;
}

int SensorManager::calculateMovingAverage(int* array, int newValue) {
    array[_historyIndex] = newValue;
    _historyIndex = (_historyIndex + 1) % MOVING_AVERAGE_SIZE;
    if (_historyIndex == 0) _historyFull = true;
    
    int sum = 0;
    int count = _historyFull ? MOVING_AVERAGE_SIZE : _historyIndex;
    for (int i = 0; i < count; i++) {
        sum += array[i];
    }
    return sum / count;
}

void SensorManager::checkAlerts() {
    // Implementa√ß√£o futura
}

void SensorManager::validateReadings() {
    // Implementa√ß√£o futura
}

float SensorManager::mapPHValue(int rawValue) {
    // Implementa√ß√£o futura
    return 7.0;
}

bool SensorManager::hasAlerts() const {
    return _alerts.tempHigh || _alerts.tempLow || 
           _alerts.phHigh || _alerts.phLow || 
           _alerts.tdsHigh || _alerts.tdsLow || 
           _alerts.levelLow || _alerts.sensorError;
}

String SensorManager::getAlertsString() const {
    // Implementa√ß√£o futura
    return "";
}

void SensorManager::calibratePH(float ph4Value, float ph7Value) {
    // Implementa√ß√£o futura
}

void SensorManager::resetCalibration() {
    // Implementa√ß√£o futura
}

String SensorManager::toJson() const {
    // Implementa√ß√£o futura
    return "";
}

void SensorManager::printReadings() const {
    // Implementa√ß√£o futura
}

void SensorManager::printDiagnostics() const {
    // Implementa√ß√£o futura
}

float SensorManager::celsiusToFahrenheit(float celsius) {
    return (celsius * 9.0 / 5.0) + 32.0;
}

float SensorManager::fahrenheitToCelsius(float fahrenheit) {
    return (fahrenheit - 32.0) * 5.0 / 9.0;
}

String SensorManager::temperatureToString(float temp, bool fahrenheit) {
    if (fahrenheit) {
        temp = celsiusToFahrenheit(temp);
    }
    return String(temp, 1) + (fahrenheit ? "¬∞F" : "¬∞C");
}

String SensorManager::phToString(float ph) {
    return String(ph, 2);
}

String SensorManager::tdsToString(int tds) {
    return String(tds) + " ppm";
}

String SensorManager::levelToString(int level) {
    return String(level) + "%";
}

bool SensorManager::addDS18B20Sensor(const String& address, const String& name) {
    if (_numDS18B20Sensors >= MAX_DS18B20_SENSORS) {
        Serial.println("‚ùå N√∫mero m√°ximo de sensores atingido!");
        return false;
    }

    // Converte o endere√ßo string para bytes
    DeviceAddress addr;
    for(int i=0; i<8; i++) {
        addr[i] = strtoul(address.substring(i*2, i*2+2).c_str(), NULL, 16);
    }

    // Verifica se o sensor existe no barramento
    bool sensorFound = false;
    DeviceAddress tempAddr;
    for(int i=0; i<_tempSensor.getDeviceCount(); i++) {
        if(_tempSensor.getAddress(tempAddr, i)) {
            if(memcmp(addr, tempAddr, 8) == 0) {
                sensorFound = true;
                break;
            }
        }
    }

    if(!sensorFound) {
        Serial.println("‚ùå Sensor n√£o encontrado no barramento!");
        return false;
    }

    // Verifica se o sensor j√° est√° cadastrado
    for(int i=0; i<_numDS18B20Sensors; i++) {
        if(memcmp(addr, _ds18b20Sensors[i].address, 8) == 0) {
            Serial.println("‚ùå Sensor j√° cadastrado!");
            return false;
        }
    }

    // Adiciona o sensor
    memcpy(_ds18b20Sensors[_numDS18B20Sensors].address, addr, 8);
    _ds18b20Sensors[_numDS18B20Sensors].name = name;
    _ds18b20Sensors[_numDS18B20Sensors].offset = 0.0;
    _ds18b20Sensors[_numDS18B20Sensors].temperature = 25.0;
    _ds18b20Sensors[_numDS18B20Sensors].rawTemperature = 25.0;
    _ds18b20Sensors[_numDS18B20Sensors].isValid = false; // Ser√° validado na primeira leitura
    _ds18b20Sensors[_numDS18B20Sensors].lastRead = 0;
    _numDS18B20Sensors++;

    // Salva os sensores no arquivo
    saveSensorsToFile();

    Serial.printf("‚úÖ Sensor DS18B20 '%s' adicionado com sucesso!\n", name.c_str());
    return true;
}

bool SensorManager::removeDS18B20Sensor(const String& address) {
    DeviceAddress addr;
    for(int i=0; i<8; i++) {
        addr[i] = strtoul(address.substring(i*2, i*2+2).c_str(), NULL, 16);
    }

    // Procura o sensor
    for(int i=0; i<_numDS18B20Sensors; i++) {
        if(memcmp(addr, _ds18b20Sensors[i].address, 8) == 0) {
            // Remove movendo os sensores restantes
            for(int j=i; j<_numDS18B20Sensors-1; j++) {
                _ds18b20Sensors[j] = _ds18b20Sensors[j+1];
            }
            _numDS18B20Sensors--;
            
            // Salva os sensores no arquivo
            saveSensorsToFile();
            
            Serial.println("‚úÖ Sensor removido com sucesso!");
            return true;
        }
    }

    Serial.println("‚ùå Sensor n√£o encontrado!");
    return false;
}

DS18B20Sensor* SensorManager::getDS18B20Sensor(const String& address) {
    DeviceAddress addr;
    for(int i=0; i<8; i++) {
        addr[i] = strtoul(address.substring(i*2, i*2+2).c_str(), NULL, 16);
    }

    for(int i=0; i<_numDS18B20Sensors; i++) {
        if(memcmp(addr, _ds18b20Sensors[i].address, 8) == 0) {
            return &_ds18b20Sensors[i];
        }
    }
    return nullptr;
}

String SensorManager::getDS18B20SensorsJson() const {
    String json = "[";
    for(int i=0; i<_numDS18B20Sensors; i++) {
        if(i > 0) json += ",";
        json += "{\"address\":\"";
        for (uint8_t j = 0; j < 8; j++) {
            if (_ds18b20Sensors[i].address[j] < 16) json += "0";
            json += String(_ds18b20Sensors[i].address[j], HEX);
        }
        json += "\",\"name\":\"" + _ds18b20Sensors[i].name + "\",";
        json += "\"temperature\":" + String(_ds18b20Sensors[i].temperature, 2) + ",";
        json += "\"rawTemperature\":" + String(_ds18b20Sensors[i].rawTemperature, 2) + ",";
        json += "\"offset\":" + String(_ds18b20Sensors[i].offset, 2) + ",";
        json += "\"isValid\":" + String(_ds18b20Sensors[i].isValid ? "true" : "false");
        json += "}";
    }
    json += "]";
    return json;
}

void SensorManager::calibrateDS18B20Sensor(const String& address, float measuredTemp) {
    DS18B20Sensor* sensor = getDS18B20Sensor(address);
    if(sensor) {
        sensor->offset = measuredTemp - sensor->rawTemperature;
        sensor->temperature = sensor->rawTemperature + sensor->offset;
        saveSensorsToFile();
        Serial.printf("‚úÖ Sensor calibrado! Offset: %.2f¬∞C\n", sensor->offset);
    }
}

void SensorManager::resetDS18B20Calibration(const String& address) {
    DS18B20Sensor* sensor = getDS18B20Sensor(address);
    if(sensor) {
        sensor->offset = 0.0;
        sensor->temperature = sensor->rawTemperature;
        saveSensorsToFile();
        Serial.println("‚úÖ Calibra√ß√£o resetada!");
    }
}

bool SensorManager::saveSensorsToFile() {
    DynamicJsonDocument doc(1024);
    JsonArray sensors = doc.createNestedArray("sensors");

    for(int i=0; i<_numDS18B20Sensors; i++) {
        JsonObject sensor = sensors.createNestedObject();
        
        // Converte o endere√ßo para string
        String address = "";
        for (uint8_t j = 0; j < 8; j++) {
            if (_ds18b20Sensors[i].address[j] < 16) address += "0";
            address += String(_ds18b20Sensors[i].address[j], HEX);
        }
        
        sensor["address"] = address;
        sensor["name"] = _ds18b20Sensors[i].name;
        sensor["offset"] = _ds18b20Sensors[i].offset;
    }

    // Serializa o JSON para string primeiro (para debug)
    String jsonStr;
    serializeJsonPretty(doc, jsonStr);
    
    Serial.println("\nüíæ Salvando sensores em arquivo...");
    Serial.println("üìÑ Conte√∫do a ser salvo:");
    Serial.println(jsonStr);

    // Abre o arquivo para escrita
    File file = FileSystemClass.open("/sensors.json", "w");
    if (!file) {
        Serial.println("‚ùå Erro ao abrir arquivo para escrita!");
        return false;
    }

    // Serializa diretamente para o arquivo
    if (serializeJson(doc, file) == 0) {
        Serial.println("‚ùå Erro ao escrever no arquivo!");
        file.close();
        return false;
    }

    file.close();
    Serial.printf("‚úÖ %d sensor(es) salvo(s) com sucesso!\n", _numDS18B20Sensors);
    return true;
}

bool SensorManager::loadSensorsFromFile() {
    // Verifica se o arquivo existe
    if (!FileSystemClass.exists("/sensors.json")) {
        Serial.println("‚ö†Ô∏è Arquivo de sensores n√£o encontrado.");
        return false;
    }

    // Abre o arquivo para leitura
    File file = FileSystemClass.open("/sensors.json", "r");
    if (!file) {
        Serial.println("‚ùå Erro ao abrir arquivo para leitura!");
        return false;
    }

    // L√™ o conte√∫do do arquivo
    String jsonStr = file.readString();
    file.close();

    Serial.println("üìÑ Conte√∫do do arquivo sensors.json:");
    Serial.println(jsonStr);

    // Parse do JSON - Buffer aumentado para ESP8266
    #ifdef ESP32
        DynamicJsonDocument doc(1024);
    #else
        DynamicJsonDocument doc(512); // Reduzido para ESP8266
    #endif
    
    DeserializationError error = deserializeJson(doc, jsonStr);
    
    if (error) {
        Serial.print("‚ùå Erro ao fazer parse do JSON: ");
        Serial.println(error.c_str());
        return false;
    }

    // Limpa os sensores atuais
    _numDS18B20Sensors = 0;

    // Carrega os sensores do arquivo
    JsonArray sensors = doc["sensors"];
    for(JsonObject sensor : sensors) {
        String address = sensor["address"].as<String>();
        String name = sensor["name"].as<String>();
        float offset = sensor["offset"] | 0.0;

        Serial.printf("\nüì• Carregando sensor '%s'...\n", name.c_str());
        Serial.printf("üìç Endere√ßo: %s\n", address.c_str());
        Serial.printf("üìä Offset: %.2f¬∞C\n", offset);

        // Converte o endere√ßo string para bytes
        DeviceAddress addr;
        for(int i=0; i<8; i++) {
            addr[i] = strtoul(address.substring(i*2, i*2+2).c_str(), NULL, 16);
        }

        // Verifica se o sensor existe no barramento
        bool sensorFound = false;
        DeviceAddress tempAddr;
        for(int i=0; i<_tempSensor.getDeviceCount(); i++) {
            if(_tempSensor.getAddress(tempAddr, i)) {
                if(memcmp(addr, tempAddr, 8) == 0) {
                    sensorFound = true;
                    break;
                }
            }
        }

        if(sensorFound && _numDS18B20Sensors < MAX_DS18B20_SENSORS) {
            // Adiciona o sensor
            memcpy(_ds18b20Sensors[_numDS18B20Sensors].address, addr, 8);
            _ds18b20Sensors[_numDS18B20Sensors].name = name;
            _ds18b20Sensors[_numDS18B20Sensors].offset = offset;
            _ds18b20Sensors[_numDS18B20Sensors].temperature = 25.0;
            _ds18b20Sensors[_numDS18B20Sensors].rawTemperature = 25.0;
            _ds18b20Sensors[_numDS18B20Sensors].isValid = true;
            _ds18b20Sensors[_numDS18B20Sensors].lastRead = 0;
            _numDS18B20Sensors++;
            
            Serial.printf("‚úÖ Sensor '%s' carregado com sucesso!\n", name.c_str());
        } else if (!sensorFound) {
            Serial.printf("‚ö†Ô∏è Sensor '%s' n√£o encontrado no barramento - ignorando\n", name.c_str());
        } else {
            Serial.println("‚ö†Ô∏è N√∫mero m√°ximo de sensores atingido!");
            break;
        }
    }

    Serial.printf("\nüì• Total de %d sensor(es) carregado(s) do arquivo\n", _numDS18B20Sensors);
    return true;
}

bool SensorManager::begin(ConfigManager* config) {
    _config = config;
    
    // Inicializa o sistema de arquivos
    if (!FileSystemClass.begin()) {
        Serial.println("‚ùå Erro ao inicializar sistema de arquivos!");
        return false;
    }
    
    Serial.println("\nüå°Ô∏è Inicializando sensores de temperatura...");
    
    #ifdef ESP32
        Serial.printf("üìç Pino OneWire: GPIO%d\n", ONE_WIRE_BUS);
    #else
        Serial.printf("üìç Pino OneWire: D2 (GPIO%d)\n", ONE_WIRE_BUS);
    #endif
    
    // Inicializa o sensor OneWire com delay de prote√ß√£o
    _tempSensor.begin();
    delay(1000); // Delay aumentado para ESP8266
    
    // Verifica se h√° sensores conectados
    int deviceCount = _tempSensor.getDeviceCount();
    Serial.printf("üîç Sensores DS18B20 encontrados: %d\n", deviceCount);
    
    if (deviceCount == 0) {
        Serial.println("‚ö†Ô∏è Nenhum sensor DS18B20 encontrado! Verifique as conex√µes.");
        Serial.println("üìå Dicas de conex√£o para ESP8266:");
        Serial.println("1. Use o pino D2 (GPIO4)");
        Serial.println("2. Resistor pullup de 4.7k entre DATA e VCC");
        Serial.println("3. Verifique a alimenta√ß√£o (3.3V)");
    }
    
    _tempSensor.setResolution(12); // Configura resolu√ß√£o para 12 bits (0.0625¬∞C)
    
    // Carrega os sensores salvos
    if (!loadSensorsFromFile()) {
        Serial.println("‚ö†Ô∏è Nenhum sensor salvo encontrado.");
    }
    
    // Carrega o offset do ConfigManager
    if (_config) {
        _data.tempOffset = _config->sensor.tempOffset;
        Serial.printf("üì• Offset de temperatura carregado: %.2f¬∞C\n", _data.tempOffset);
    }
    
    Serial.println("‚úÖ Sensores inicializados");
    return true;
} 